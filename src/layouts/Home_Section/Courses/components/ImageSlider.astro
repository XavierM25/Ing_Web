---
interface Image {
  src: string;
  alt: string;
}

interface Props {
  images: Image[];
}

const { images } = Astro.props;
---

<div class="relative w-full max-w-xl mx-auto">
  <div class="overflow-hidden rounded-lg">
    <div id="slider" class="flex transition-transform duration-300 ease-in-out cursor-grab active:cursor-grabbing select-none">
        {images.map((image) => (
          <img src={image.src} alt={image.alt} class="w-full h-64 object-cover flex-shrink-0 -webkit-user-drag:none user-select-none" />
        ))}
      </div>
      
  </div>
  <button id="prevBtn" class="absolute left-2 top-1/2 transform -translate-y-1/2 bg-white bg-opacity-50 p-2 rounded-full">
    &lt;
  </button>
  <button id="nextBtn" class="absolute right-2 top-1/2 transform -translate-y-1/2 bg-white bg-opacity-50 p-2 rounded-full">
    &gt;
  </button>
</div>

<style>
    #slider {
  user-select: none; /* Evita la selecci칩n de texto o im치genes */
}

img {
  -webkit-user-drag: none; /* Previene arrastrar la imagen en navegadores WebKit */
  user-select: none; /* Evita que las im치genes sean seleccionables */
}
</style>

<script>
  const slider = document.getElementById('slider') as HTMLElement;
  const prevBtn = document.getElementById('prevBtn') as HTMLButtonElement;
  const nextBtn = document.getElementById('nextBtn') as HTMLButtonElement;
  let currentIndex = 0;
  let startX: number;
  let isDragging = false;
  let isClicking = false;

  function updateSlider() {
    const slideWidth = slider.clientWidth;
    slider.style.transform = `translateX(-${currentIndex * slideWidth}px)`;
  }

  function nextSlide() {
    currentIndex = (currentIndex + 1) % slider.children.length;
    updateSlider();
  }

  function prevSlide() {
    currentIndex = (currentIndex - 1 + slider.children.length) % slider.children.length;
    updateSlider();
  }

  prevBtn.addEventListener('click', prevSlide);
  nextBtn.addEventListener('click', nextSlide);

  slider.addEventListener('mousedown', (e: MouseEvent) => {
    isDragging = true;
    isClicking = true;
    startX = e.pageX - slider.offsetLeft;
    slider.style.cursor = 'grabbing';
  });

  slider.addEventListener('mousemove', (e: MouseEvent) => {
    if (!isDragging) return;
    const x = e.pageX - slider.offsetLeft;
    const walk = (x - startX) * 2;
    if (Math.abs(walk) > 100) {
      if (walk > 0) {
        prevSlide();
      } else {
        nextSlide();
      }
      isDragging = false;
      isClicking = false;  // Evita que cuente como clic
    }
  });

  slider.addEventListener('mouseup', () => {
    isDragging = false;
    slider.style.cursor = 'grab';
    setTimeout(() => {
      isClicking = false;  // Evita acci칩n de clic en breve
    }, 0);
  });

  slider.addEventListener('mouseleave', () => {
    isDragging = false;
    slider.style.cursor = 'grab';
  });

  window.addEventListener('resize', updateSlider);
</script>
